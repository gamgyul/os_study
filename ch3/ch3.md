# 프로세스

프로세스란 실행 중인 프로그램이다. 프로세스는 함수의 매개변수와 로컬 변수와 같은 임시자료인 스택 및 전역변수를 수록하는 데이터 영역 힙 영역등의 메모리들을 포함한다.

## 프로세스의 상태

* new: 생성중인 프로세스
* running: 실행중인 프로세스
* wait: 대기중인 프로세스
* ready: 처리기에 할당을 기다리는 프로세스
* terminated: 종료되는 프로세스

## 프로세스 제어 블록(Process Contol Block)

프로세스는 PCB에 의해 표현되며 PCB는 프로세스의 정보를 담고있다.
PCB에 담겨있는 정보
* 프로세스 상태
* 프로그램 카운터
* CPU register
* CPU 스케쥴링 정보
* 메모리 관리 정보
* accounting 정보
* 입출력 상태 정보

context switching 이 일어날때 이 PCB를 저장하고 호출하는 방식으로 일어남.

## 프로세스 스케쥴링

CPU이용을 최대화하기 위해서 OS는 프로세스 스케줄링을 통해 프로세스 사이에서 CPU를 빈번하게 교환하는 방법으로 여러 프로세스가 효율적으로 동작할 수 있게 한다.

### 스케줄링 큐

프로세스가 시스템으로 들어오면 큐로 관리가됨. 준비된 프로세르르 모아두는 큐, 장치를 사용하기 위해 대기하는 device queue 가 있다. 프로세스들은 프로세스가 종료되기까지 위의 큐에서 상태가 전환되는것을 반복한다.

### 스케쥴러

운영체제는 스케줄러를 통해서 프로세스들을 선택해 실행하게된다. 장기 스케줄러의 경우 프로세스들을 선택하여 메모리로 적재하고 단기 스케줄러(CPU 스케줄러)는 프로세스에게 CPU를 할당한다.

단기 스케줄러는 자주 프로세스를 선택하고(100ms 단위에서 결졍) 장기스케줄러는 실행 빈도수가 그에 비해 훨씬 적다(분단위). UNIX 및 WINDOWS는 장기 스케줄러가 존재하지 않는다.

### 컨텍스트 스위칭

인터럽트가 발생하면 운영체제가 CPU를 현제 작업에게서 뺏게되는데 이작업은 프로세스를 중단했다 다시 실행하는 과정과 같다. 그래서 위에 언급한 PCB에 context를 저장했다가 다른 프로세스의 저장된 상태를 복구하는 작업을 하게 되는데 이 과정이 context switching 이라 한다.

## 프로세스의 대한 연산

### 프로세스 생성

프로세스는 실행도중 새로운 프로세스를 생성할수 있고 생성하는 프로세스가 ```부모 프로세스``` 
생성되는 프로세스가 ```자식 프로세스``` 라고 한다. 그 결과로 프로세스의 **트리**가 형성된다.

UNIX의 경우 init에서 시작되서 트리 형태를 이루는데 프로세스마다 프로세스를 구별하기 위한 식별자인 ```PID```를 가지고 있다.

* 프로세스의 자원 할당에 관련해서 UNIX의 예제를 확인.
    * 새로운 프로세스는 ```fork()``` 로 생성됨. 이 프로세스는 부모프로세스의 주소공간의 복사본으로 구성.
    * 두 프로세스중 하나가 자신의 메모리공간을 바꾸기 위해 ```exec()```을 호출. ```exec()```은 프로그램을 메모리로 적재후 실행한다.
    * 부모프로세스의 경우 ```wait()```을 통해 자식 프로세스가 종료되길 기다린 이후 ```exit()```을 통해 종료한다. 

### 프로세간 통신

프로세스간 통신(Inter Process Communication (IPC))에는 두가지 방법이 있다.

1. 공유 메모리
    * 프로세들이 같은 메모리 영역을 공유해 해당 구역에 데이터를 읽고 씀
    * 메세지 전달 방식에 비해 빠름.
    * 구현이 불편하고 충돌을 고려해야함.
2. 메세지 전달
    * 메세지를 교환하는 방식으로 통신
    * 충돌을 고려하지 않아도 됨.
    * 시스템 호출을 사용하므로 시간 소비가 있음.


**공유 메모리**

일반적으로 프로세스는 다른프로세스가 메모리에 접근하는것을 금지하지만 이 조건을 제거하고 공유메모리 세그먼트를 다른프로세스가 접근할 수 있게하고 그 공간에 읽고 쓰는 방식으로 통신을 한다. 

```c
// 생산자 소비자 모델 BUFFER_SIZE까지 사용
//producer
item nextProduced;

while(true) {
    while(in == out && cnt == BUFFER_SIZE) 
        ;
    buffer[in] = nextProduced;
    in = (in + 1) % BUFFER_SIZE;
    cnt++;
}

//consumer
item nextConsumed;
while(true) {
    while(in  == out && cnt ==0)
        ;
    nextConsumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;
    cnt--;
}
```

**메세지 전달 시스템**

메세지를 통해 동작하는 방식으로 네트워크에 의해 연결된 분산환경에서 유용하다. 메세지 전달 시스템은 최소 2가지 메소드를 제공하는데 **send**와 **receive**이다. 
* 하나의 링크와 send/receive연산을 논리적으로 구현하는 방법
    * 직접/간접 통신
    * 동기/비동기 통신
    * 자동/명시적 버퍼링
* 위 특성들의 쟁점
    * naming:  통신을 원하는 프로세스는 서로를 가리킬 수 있는 방법이 있어야홤.
        * 직접통신: 수신, 송신자의 이름을 명시. 
            * 두 프로세스 사이의 연결이 구축됨.
            * 통프로세스 쌍에 하나의 연결만이 구축됨.
        * 간접통신: 메세지는 메일박스, 포트에 송신, 및 수신됨
    * synchronization: 동기화
        * blocking /nonblocking

### 서버 클라이언트 환겨에서의 통신
#### 소켓
* ip / port 라는 접합으로 구별
    * 1024까지는 well-known port라고 한다. (ex http:80, ftp:21)

#### 파이프
생산자 소비자 형태의 프로세스 통신을 하고 보통의 파이프는 한쪽방향으로 데이터를 전송하는 방식이다.
UNIX의 경우 ```pipe(int fd[])``` 함수를 상 요해 구축한다. 보통 파이프는 생성한 프로세스만 접근이 가능해 통상적으로 부모프로세스가 자식프로세스와 통신을 하기 위해 사용한다. 




