# 프로세스

프로세스란 실행 중인 프로그램이다. 프로세스는 함수의 매개변수와 로컬 변수와 같은 임시자료인 스택 및 전역변수를 수록하는 데이터 영역 힙 영역등의 메모리들을 포함한다.

## 프로세스의 상태

* new: 생성중인 프로세스
* running: 실행중인 프로세스
* wait: 대기중인 프로세스
* ready: 처리기에 할당을 기다리는 프로세스
* terminated: 종료되는 프로세스

## 프로세스 제어 블록(Process Contol Block)

프로세스는 PCB에 의해 표현되며 PCB는 프로세스의 정보를 담고있다.
PCB에 담겨있는 정보
* 프로세스 상태
* 프로그램 카운터
* CPU register
* CPU 스케쥴링 정보
* 메모리 관리 정보
* accounting 정보
* 입출력 상태 정보

context switching 이 일어날때 이 PCB를 저장하고 호출하는 방식으로 일어남.

## 프로세스 스케쥴링

CPU이용을 최대화하기 위해서 OS는 프로세스 스케줄링을 통해 프로세스 사이에서 CPU를 빈번하게 교환하는 방법으로 여러 프로세스가 효율적으로 동작할 수 있게 한다.

### 스케줄링 큐

프로세스가 시스템으로 들어오면 큐로 관리가됨. 준비된 프로세르르 모아두는 큐, 장치를 사용하기 위해 대기하는 device queue 가 있다. 프로세스들은 프로세스가 종료되기까지 위의 큐에서 상태가 전환되는것을 반복한다.

### 스케쥴러

운영체제는 스케줄러를 통해서 프로세스들을 선택해 실행하게된다. 장기 스케줄러의 경우 프로세스들을 선택하여 메모리로 적재하고 단기 스케줄러(CPU 스케줄러)는 프로세스에게 CPU를 할당한다.

단기 스케줄러는 자주 프로세스를 선택하고(100ms 단위에서 결졍) 장기스케줄러는 실행 빈도수가 그에 비해 훨씬 적다(분단위). UNIX 및 WINDOWS는 장기 스케줄러가 존재하지 않는다.

### 컨텍스트 스위칭

인터럽트가 발생하면 운영체제가 CPU를 현제 작업에게서 뺏게되는데 이작업은 프로세스를 중단했다 다시 실행하는 과정과 같다. 그래서 위에 언급한 PCB에 context를 저장했다가 다른 프로세스의 저장된 상태를 복구하는 작업을 하게 되는데 이 과정이 context switching 이라 한다.

## 프로세스의 대한 연산

### 프로세스 생성

프로세스는 실행도중 새로운 프로세스를 생성할수 있고 생성하는 프로세스가 ```부모 프로세스``` 
생성되는 프로세스가 ```자식 프로세스``` 라고 한다. 그 결과로 프로세스의 **트리**가 형성된다.

UNIX의 경우 init에서 시작되서 트리 형태를 이루는데 프로세스마다 프로세스를 구별하기 위한 식별자인 ```PID```를 가지고 있다.

* 프로세스의 자원 할당에 관련해서 UNIX의 예제를 확인.
    * 새로운 프로세스는 ```fork()``` 로 생성됨. 이 프로세스는 부모프로세스의 주소공간의 복사본으로 구성.
    * 두 프로세스중 하나가 자신의 메모리공간을 바꾸기 위해 ```exec()```을 호출. ```exec()```은 프로그램을 메모리로 적재후 실행한다.
    * 부모프로세스의 경우 ```wait()```을 통해 자식 프로세스가 종료되길 기다린 이후 ```exit()```을 통해 종료한다. 

### 프로세간 통신

프로세스간 통신(Inter Process Communication (IPC))에는 두가지 방법이 있다.

1. 공유 메모리
    * 프로세들이 같은 메모리 영역을 공유해 해당 구역에 데이터를 읽고 씀
    * 메세지 전달 방식에 비해 빠름.
    * 구현이 불편하고 충돌을 고려해야함.
2. 메세지 전달
    * 메세지를 교환하는 방식으로 통신
    * 충돌을 고려하지 않아도 됨.
    * 시스템 호출을 사용하므로 시간 소비가 있음.


**공유 메모리**



